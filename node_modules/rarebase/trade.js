/*******************************************************************
*
* TRADE
*
* - public methods
*   - write methods
*     - save: save a token to DB
*     - del: delete tokens that match a condition
*   - read methods
*     - query: query tokens
*     - queryOne: query one token
*   - network methods
*     - push: send a token
*     - pull: download a token
* - private methods
*   - normalize
*   - validate
*   - validateDiff
*
*******************************************************************/
const diff = require('deep-diff').diff;
const cidar = require('cidar')
class Trade {
  constructor(knex, query) {
    this.knex = knex
    this.q = query
  }

  // 1. PUBLIC WRITE METHODS
  async save(body) {
    // Post: Only append (Trade positions are never updated. Instead, new positions are posted)
    body = this.normalize(body)
    this.validate(body)
    let now = Date.now()
    let stub = {
      body: JSON.stringify(body),
      created_at: now,
    }
    if (body.make && body.make.assetType.tokenId) stub.makeId = body.make.assetType.tokenId
    if (body.take && body.take.assetType.tokenId) stub.takeId = body.take.assetType.tokenId
    if (body.maker) stub.maker = body.maker.toLowerCase()
    if (body.taker) stub.taker = body.taker.toLowerCase()
    if (body.make) {
      if (body.make.assetType.contract) {
        stub.makeType = body.make.assetType.assetClass + "." + body.make.assetType.contract.toLowerCase()
      } else {
        stub.makeType = body.make.assetType.assetClass
      }
    }
    if (body.take) {
      if (body.take.assetType.contract) {
        stub.takeType = body.take.assetType.assetClass + "." + body.take.assetType.contract.toLowerCase()
      } else {
        stub.takeType = body.take.assetType.assetClass
      }
    }
    let cid = await cidar.file(Buffer.from(stub.body))
    stub.cid = cid
    await this.knex("trades")
      .insert(stub)
      .onConflict("cid")
      .ignore()
  }
  async del(where) {
    if (Array.isArray(where)) {
      await this.knex("trades").where(...where).del()
    } else if (typeof where === 'object') {
      await this.knex("trades").where(where).del()
    } else {
      throw new Error("the condition must be either array or a non-empty object")
    }
  }

  // 2. PUBLIC READ METHODS
  query(query) {
    query.from = "trades"
    return this.q.query(query)
  }
  queryOne(query) {
    query.from = "trades"
    return this.q.queryOne(query)
  }

  // 3. PRIVATE METHODS
  normalize(body) {
    let sides = ["make", "take"]
    for(let side of sides) {
      if (body[side]) {
        if (body[side].assetType.contract) {
          body[side].assetType.contract = body[side].assetType.contract.toLowerCase()
        }
        if (body[side].assetType.creators) {
          for(let i=0; i<body[side].assetType.creators.length; i++) {
            body[side].assetType.creators[i].account = body[side].assetType.creators[i].account.toLowerCase()
          }
        }
        if (body[side].assetType.royalties) {
          for(let i=0; i<body[side].assetType.royalties.length; i++) {
            body[side].assetType.royalties[i].account = body[side].assetType.royalties[i].account.toLowerCase()
          }
        }
      }
    }
    if (body.maker) body.maker = body.maker.toLowerCase()
    if (body.taker) body.taker = body.taker.toLowerCase()
    return body
  }
  validate(body) {
    // cannot insert without a signature
    if (!body.signature) {
      throw new Error("signature required")
      return
    }
    // must have a side: either 'make' or 'take'
    if (!body.make && !body.take) {
      throw new Error("must have at least 'make' or 'take' attribute")
      return
    }
  }
  validateDiff(existingBody, newBody) {
    // assetType should not have changed
    let sides = ["make", "take"]
    for(let side of sides) {
      let d = diff(existingBody[side], newBody[side])
      if (d) {
        throw new Error("the contents have the trade have been mutated")
        return
      }
    }
    // data should not have changed
    let d = diff(existingBody.data, newBody.data)
    if (d) {
      throw new Error("the contents have the trade have been mutated")
      return
    }
  }
}
module.exports = Trade

/*******************************************************************
*
* TOKEN
*
* - public methods
*   - write methods
*     - save: save a token to DB
*     - del: delete tokens that match a condition
*   - read methods
*     - query: query tokens
*     - queryOne: query one token
*   - network methods
*     - push: send a token
*     - pull: download a token
* - private methods
*   - insert
*   - normalize
*   - validate
*
*******************************************************************/
const diff = require('deep-diff').diff;
const cidar = require('cidar')
class Token {
  constructor(knex, query) {
    this.knex = knex
    this.q = query
  }

  // 1. PUBLIC WRITE METHODS
  async save(body) {
    body = this.normalize(body)
    this.validate(body)
    let tokenId = body.tokenId
    let found = await this.knex("tokens").where({ tokenId }).limit(1)
    if (found.length > 0) {
      let existingBody = JSON.parse(found[0].body)

      // 0. validate the diff
      this.validateDiff(existingBody, body)

      // 1. merge new signatures into the existing signatures array
      let existingSignatures = existingBody.signatures
      let newSignatures = body.signatures

      // merge non null values into null values
      for(let i=0; i<newSignatures.length; i++) {
        if (newSignatures[i] === null && existingSignatures[i] !== null) {
          body.signatures[i] = existingSignatures[i]
        }
      }
      
      // 2. update tokens db
      let updated = await this.knex("tokens")
      .where({ tokenId })
      .update({
        body: JSON.stringify(body),
        created_at: existingBody.created_at,
        updated_at: Date.now()
      })

      // check the incoming signatures, find the associated creator and update
      let existingSigs = existingBody.signatures
      let newSigs = body.signatures

      for(let i=0; i<newSigs.length; i++) {
        if (newSigs[i] && !existingSigs[i]) {
          // update the corresponding creator with "signed: true"
          await this.knex("creators")
          .where({
            tokenId,
            address: body.creators[i].account
          })
          .update({
            signed: true
          })
        }
      }
      return updated
    } else {
      let res = await this.insert(body)
      return res
    }
  }
  async del(where) {
    if (Array.isArray(where)) {
      await this.knex("tokens").where(...where).del()
    } else if (typeof where === 'object') {
      await this.knex("tokens").where(where).del()
    } else {
      throw new Error("the condition must be either array or a non-empty object")
    }
  }

  // 2. PUBLIC READ METHODS
  query(query) {
    query.from = "tokens"
    return this.q.query(query)
  }
  queryOne(query) {
    query.from = "tokens"
    return this.q.queryOne(query)
  }


  // 3. PRIVATE METHODS
  async insert(body) {
    body = this.normalize(body)
    this.validate(body)
    let bodyStr = JSON.stringify(body)
    let cid = await cidar.file(Buffer.from(bodyStr))
    // 1. Insert to tokens
    await this.knex("tokens").insert({
      cid: cid,
      tokenId: body.tokenId,
      uri: body.uri,
      name: body.metadata.name,
      description: body.metadata.description,
      image: body.metadata.image,
      type: body["@type"],
      contract: body.contract,
      body: bodyStr,
      created_at: Date.now(),
      updated_at: Date.now()
    })
    // 2. Insert to creators
    for(let i=0; i<body.creators.length; i++) {
      let stub = {
        tokenId: body.tokenId,
        address: body.creators[i].account
      }
      if (body.signatures && body.signatures[i]) {
        stub.signed = true
      }
      await this.knex("creators").insert(stub)
    }
  }
  normalize(body) {
    // normalize body before doing anything
    // creators.account => lowercase
    // contract => lowercase
    if (body.contract) body.contract = body.contract.toLowerCase()
    if (body.creators) {
      for(let i=0; i<body.creators.length; i++) {
        body.creators[i].account = body.creators[i].account.toLowerCase()
      }
    }
    if (body.royalties) {
      for(let i=0; i<body.royalties.length; i++) {
        body.royalties[i].account = body.royalties[i].account.toLowerCase()
      }
    }
    // adhoc uri / tokenURI
    if (body.tokenURI) body.uri = body.tokenURI
    if (body.uri) body.tokenURI = body.uri
    return body
  }
  validate(body) {
    // 0. all attributes must exist
    let attributes = ["metadata", "@type", "uri", "tokenId", "tokenURI", "contract", "creators", "signatures"] 
    for(let key of attributes) {
      if (!body[key]) {
        throw new Error(`${key} doesn't exist`)
        return false
      }
    }

    // 1. creators array and signatures array length must match
    if (body.signatures.length !== body.creators.length) {
      throw new Error("creators and signatures sizes don't match")
      return false
    }
    // 2. only string or null should be allowed inside signatures array
    let validSigs = body.signatures.filter((sig) => {
      return typeof sig === "string" || sig === null
    })
    if (validSigs.length !== body.signatures.length) {
      throw new Error("the signatures array must contain either string or null values")
      return false
    }

    // there must be at least one item in the creators array
    if (body.creators.length < 1) {
      throw new Error("there must be at least one item in the creators array")
      return false;
    }
    // 2. creators array values should add up to 10000
    let total = 0
    for(let creator of body.creators) {
      total += creator.value 
    }
    if (total !== 10000) {
      throw new Error("all values in the creators array must add up to 10000")
      return false
    }
    // For addresses that start with 0
    let leftPad = ""
    for(let i=0; i<77 - body.tokenId.length; i++) {
      leftPad += "0"
    }
    let derivedAddress = "0x" + (leftPad + BigInt("" + body.tokenId).toString(16)).slice(0, 40).toLowerCase()
    if (derivedAddress !== body.creators[0].account.toLowerCase()) {
      throw new Error("the tokenId must be derived from the account: creators[0].account")
    }

    return true
  }
  validateDiff(existingBody, newBody) {
    // 1. ensure that the contents haven't been tampered with
    // 1.1. check basic attributes
    let attributes = ["@type", "uri", "tokenId", "tokenURI", "contract", "supply"] 
    for(let attribute of attributes) {
      if (existingBody[attribute] !== newBody[attribute]) {
        throw new Error(`${attribute} has changed`)
        return false
      }
    }
    let meta = ["name", "description", "image"] 
    for(let attribute of meta) {
      if (existingBody[attribute] !== newBody[attribute]) {
        throw new Error(`metadata.${attribute} has changed`)
        return false
      }
    }
    // 1.2. check nested attributes (creators & royalties)
    let nestedAttributes = ["creators", "royalties"]
    for(let attribute of nestedAttributes) {
      let d = diff(existingBody[attribute], newBody[attribute])
      if (d) {
        throw new Error(`${attribute} has changed`)
        return false;
      }
    }
    return true;

  }


}
module.exports = Token
